Programação Orientada a Objetos (POO)

O que é POO?

Programação Orientada a Objetos (POO) é um paradigma de programação que utiliza "objetos" para modelar dados e funcionalidades de um sistema. 
Em vez de pensar em um programa como uma série de instruções e funções, a POO organiza o código em entidades chamadas objetos, que combinam dados (atributos) e comportamentos (métodos). 
Esses objetos podem interagir entre si e criar hierarquias de classes, permitindo uma forma mais modular e reutilizável de escrever software. A POO facilita a criação de sistemas complexos, 
promovendo organização, escalabilidade e manutenção.

1. Conceitos básicos de POO

Classe: É como uma planta baixa ou um molde para criar objetos. Por exemplo, uma classe "Carro" pode definir as características e funcionalidades básicas que todos os carros terão.
Objeto: É uma instância concreta de uma classe. Usando a classe "Carro", um objeto seria um carro específico, como um "Fusca 1970".
Instanciação: É o processo de criar um novo objeto a partir de uma classe. É como construir uma casa usando a planta baixa.
Atributos: São as características de um objeto. Por exemplo, um carro pode ter atributos como cor, modelo e ano.
Métodos: São as ações que um objeto pode realizar. Por exemplo, um carro pode ter métodos como "acelerar" e "frear".
2. Encapsulamento

Modificadores de acesso: Definem quem pode acessar ou modificar os atributos e métodos de um objeto. É como definir quem pode entrar em uma sala específica.
Getters e Setters: São métodos especiais que permitem ler (get) ou alterar (set) os atributos de um objeto. Pense neles como portas que você pode abrir para acessar ou mudar algo.
3. Herança

Classe base: É uma classe que fornece características e funcionalidades comuns para outras classes. Por exemplo, "Veículo" pode ser uma classe base para "Carro" e "Moto".
Classe derivada: É uma classe que herda características de uma classe base. Usando o exemplo anterior, "Carro" e "Moto" seriam classes derivadas de "Veículo".
Sobrescrita de métodos: Permite que uma classe derivada modifique ou substitua o comportamento de um método da classe base.
4. Polimorfismo

Sobrecarga de métodos: Permite que diferentes métodos tenham o mesmo nome, mas com diferentes funcionalidades dependendo dos parâmetros fornecidos.
Redefinição de métodos: Permite que uma classe derivada forneça uma nova implementação para um método que foi definido na classe base.
5. Abstração

Classes abstratas: São classes que não podem ser instanciadas diretamente e servem como base para outras classes. Elas definem métodos que devem ser implementados pelas classes derivadas.
Métodos abstratos: São métodos que são declarados na classe abstrata, mas não possuem implementação. As classes derivadas são responsáveis por fornecer a implementação desses métodos.
6. Interfaces

Definição e implementação: Uma interface define um conjunto de métodos que uma classe deve implementar. É como um contrato que uma classe deve seguir.
Implementação múltipla: Permite que uma classe implemente várias interfaces, fornecendo uma forma de combinar diferentes funcionalidades.
7. Composição e agregação

Composição: É uma relação onde um objeto é parte essencial de outro objeto e não pode existir independentemente. Por exemplo, um "Motor" é parte de um "Carro" e não faz sentido sem ele.
Agregação: É uma relação onde um objeto pode ser parte de outro, mas pode existir independentemente. Por exemplo, um "Departamento" pode ter muitos "Funcionários", mas os funcionários podem existir fora do departamento.
8. Relações entre objetos

Associação: É uma relação entre dois objetos onde eles interagem de alguma forma. Por exemplo, um "Professor" pode estar associado a um "Curso".
Dependência: É uma relação onde um objeto depende de outro para funcionar corretamente. Por exemplo, um "Carro" depende de um "Motor" para funcionar.
Composição: Como mencionado antes, é uma relação onde um objeto é parte essencial de outro e não pode existir sem ele.
Agregação: Também mencionado antes, é uma relação onde um objeto pode ser parte de outro, mas pode existir por conta própria.
9. Design Patterns

Singleton: Garante que uma classe tenha apenas uma instância e fornece um ponto de acesso global a ela.
Factory: Cria objetos sem especificar a classe exata do objeto que será criado.
Observer: Permite que um objeto notifique outros objetos sobre mudanças em seu estado.
Strategy: Permite que uma classe defina um conjunto de algoritmos e os torne intercambiáveis.
Decorator: Permite adicionar funcionalidades a um objeto de forma dinâmica.
10. Princípios SOLID

Single Responsibility Principle (SRP): Cada classe deve ter uma única responsabilidade ou motivo para mudar.
Open/Closed Principle (OCP): As classes devem ser abertas para extensão, mas fechadas para modificação.
Liskov Substitution Principle (LSP): Objetos de uma classe derivada devem poder substituir objetos de uma classe base sem alterar o comportamento correto do programa.
Interface Segregation Principle (ISP): Uma classe não deve ser forçada a implementar interfaces que não usa.
Dependency Inversion Principle (DIP): Dependa de abstrações, não de implementações concretas.
11. UML para POO

Diagramas de classes: Mostram as classes de um sistema e as relações entre elas.
Diagramas de objetos: Mostram instâncias de classes e suas relações em um momento específico.
Diagramas de sequência: Mostram como os objetos interagem entre si em uma sequência de eventos.
12. Testes e Depuração

Testes unitários: Verificam se as partes individuais de um programa (como métodos ou classes) funcionam corretamente.
Mocking: Simula o comportamento de objetos para testar uma parte específica do código sem depender de outras partes.
Análise de cobertura de testes: Avalia a extensão em que o código foi testado por testes unitários.
